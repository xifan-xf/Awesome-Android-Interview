## 其他扩展面试题

### 一、Kotlin （⭐⭐）

#### 1、Kotlin 特性，和 Java 相比有什么不同的地方?

- 能直接与Java相互调用，能与Java工程共存
- 大大减少样板代码
- 可以将Kotlin代码编译为无需虚拟机就可运行的原生二进制文件
- 支持协程
- 支持高阶函数
- 语言层面解决空指针问题
- 对字符串格式化的处理（$变量名）
- 更像Python的语法
- 对λ表达式支持更好

https://mp.weixin.qq.com/s/FqXLNz5p9M-5vcMUkxJyFQ


#### 2、Kotlin为什么能和Java混编?

#### 3、什么是协程？
Kotlin协程是一种轻量级的并发编程工具，它提供了一种简洁的方式来处理异步任务，避免了传统线程和回调的复杂性。下面是Kotlin协程的简要原理：

### 协程的基本概念

协程是一种轻量级的线程，它可以在某个时刻挂起（suspend）并在稍后的某个时刻恢复执行。与传统的线程相比，协程更加高效，因为它可以避免线程的创建和切换开销。

### 挂起函数与协程构建器

Kotlin协程通过挂起函数（suspend function）来实现挂起和恢复的操作。挂起函数是一种特殊类型的函数，它可以在内部使用`suspend`关键字来挂起执行，然后在某些条件满足时恢复执行。

协程构建器（coroutine builder）是用于创建协程的函数，它可以是`launch`、`async`、`runBlocking`等。通过协程构建器，可以将挂起函数包装成协程，从而实现异步执行的功能。

### 协程调度器

协程调度器（Coroutine Dispatcher）负责协程的调度和执行。它可以控制协程运行的线程池、线程调度策略等。在Kotlin中，常见的调度器有`Dispatchers.Default`（默认调度器，使用共享的线程池）、`Dispatchers.IO`（用于I/O操作的调度器）和`Dispatchers.Main`（用于Android主线程）等。

### 挂起点与挂起函数的转换

在协程中，挂起点是指导致协程挂起的地方。挂起点可以是`delay()`、`suspendCoroutine()`等挂起函数，也可以是调用其他挂起函数的地方。当协程遇到挂起点时，它会将当前的执行状态保存起来，并暂停执行，直到某个条件满足后再恢复执行。

### 协程的执行流程

协程的执行流程通常分为以下几个步骤：

1. 创建协程：使用协程构建器创建一个协程。
2. 执行协程：将协程提交给调度器执行，调度器会根据具体的调度策略将协程分配给线程池中的某个线程执行。
3. 执行到挂起点：当协程遇到挂起点时，它会将当前的执行状态保存起来，并暂停执行。
4. 恢复执行：当某个条件满足时，协程会从之前保存的执行状态处恢复执行，继续执行后续的代码。

### 总结

Kotlin协程通过挂起函数、协程构建器、调度器等机制实现了一种轻量级的并发编程模型。它简化了异步任务的处理，提高了代码的可读性和可维护性，是Kotlin语言中的重要特性之一。

协程是一种轻量级的并发编程工具，它允许在代码中创建异步、非阻塞的任务，而无需使用传统的多线程和回调机制。协程的原理涉及到挂起、调度和状态机等概念。

### 基本原理

1. **挂起和恢复：** 协程通过挂起和恢复的机制实现异步执行。当协程遇到挂起点（例如IO操作、长时间计算等）时，它会暂停当前任务的执行，并将执行状态保存下来，然后让出CPU执行权。当挂起的条件满足时，协程会被恢复，并继续执行下去。

2. **非阻塞：** 协程的挂起是非阻塞的，即在协程挂起时，它不会阻塞线程或进程的执行，因此可以在单个线程上运行多个协程，提高了资源利用率。

3. **调度器：** 协程需要一个调度器来管理和调度协程的执行。调度器负责决定何时执行哪个协程，以及在何时恢复挂起的协程。不同的调度器可以实现不同的调度策略，例如抢占式调度、协作式调度等。

4. **状态机：** 协程的实现通常基于状态机的概念。每个协程都有自己的状态，包括运行、挂起、完成等。协程在不同状态之间转换，并在状态转换时执行相应的操作，例如保存和恢复执行状态。

### 实现方式

1. **基于线程池：** 协程可以基于线程池来实现，并利用线程池的多线程特性来执行协程任务。在这种情况下，协程的调度和执行由线程池管理，可以实现高效的并发执行。

2. **基于事件循环：** 协程也可以基于事件循环（Event Loop）来实现，类似于JavaScript中的异步编程模型。在这种情况下，协程的执行由事件循环来驱动，可以实现非阻塞的IO操作和高效的事件处理。

3. **基于生成器：** 协程的实现还可以基于生成器（Generator）或协程语法糖来实现。在这种情况下，编译器会将协程代码转换为状态机或生成器的形式，从而实现挂起和恢复的功能。

综上所述，协程的原理涉及到挂起、调度、状态机等概念，通过合适的实现方式可以实现异步、非阻塞的任务执行。

`suspend`是Kotlin中用于声明挂起函数的关键字。挂起函数是一种特殊类型的函数，它可以在内部使用`suspend`关键字来挂起执行，然后在某些条件满足时恢复执行。下面是`suspend`的简要原理：

### 基本原理

1. **挂起点标记：** 在编译期间，Kotlin编译器会将挂起函数中的每个挂起点标记起来。挂起点通常是挂起函数内部的`suspend`修饰的函数调用，比如`delay()`、`suspendCoroutine()`等。

2. **生成状态机：** 编译器会将挂起函数转换为一个状态机（state machine），用于管理函数的执行状态。状态机包含了函数的所有可能的执行状态，以及在不同状态之间转换时的操作。

3. **状态转换：** 当挂起函数遇到挂起点时，它会将当前的执行状态保存下来，并暂停执行。然后，当挂起条件满足时，函数会被恢复，并继续执行下去。状态转换的过程由状态机管理，并根据挂起条件决定何时进行状态转换。

### 实现方式

1. **协程：** 挂起函数通常用于协程中，用于声明挂起点并实现非阻塞的异步操作。当协程遇到挂起点时，它会挂起当前任务的执行，并将控制权让给其他协程或线程。当挂起条件满足时，协程会被恢复，并继续执行下去。

2. **调用链：** 挂起函数可以通过调用链的方式串联起来，形成异步操作的执行顺序。当一个挂起函数被调用时，它会在遇到挂起点前挂起执行，并返回一个`Continuation`对象，用于在挂起条件满足时恢复执行。这样就可以构建出复杂的异步操作链，而不需要使用回调函数或者Future等方式。

综上所述，`suspend`关键字用于声明挂起函数，在编译期间通过状态机的方式实现挂起和恢复的功能。挂起函数通常用于协程中，用于实现非阻塞的异步操作，可以通过调用链的方式构建复杂的异步操作流程。

线程（Thread）和协程（Coroutine）是用于并发编程的两种不同的编程模型，它们之间有一些重要的区别：

1. **并发模型：**
   - 线程是操作系统提供的并发执行的基本单元，它由操作系统调度和管理，可以同时执行多个线程，每个线程都拥有自己的执行上下文（包括堆栈、寄存器等）。
   - 协程是一种用户态的轻量级线程，它是由程序员控制和调度的，并且在运行时可以暂停、恢复和终止。协程通常在单个线程内执行，但可以在不同的线程之间切换。

2. **资源消耗：**
   - 线程在创建时会分配操作系统资源（如堆栈空间），因此线程的创建和销毁都会带来一定的开销，尤其是在大规模并发的情况下。
   - 协程不需要额外的操作系统资源，它是在用户空间管理的，因此创建和销毁开销较小。多个协程可以在同一个线程内执行，减少了线程切换的开销。

3. **调度方式：**
   - 线程的调度是由操作系统内核进行管理的，它的调度策略可能是抢占式的（Preemptive），也可能是协作式的（Cooperative）。
   - 协程的调度由程序员控制，程序员可以自由地选择何时暂停、恢复和切换协程，因此可以实现更加灵活的调度策略。

4. **并发编程模型：**
   - 线程通常采用共享内存的并发模型，多个线程共享同一份内存空间，通过锁机制来保护共享资源的访问。
   - 协程通常采用消息传递的并发模型，不同的协程之间通过消息传递来进行通信，每个协程拥有自己的状态和堆栈，不共享内存。

5. **异常处理：**
   - 线程的异常处理通常依赖于线程本身的异常处理机制，可能会导致整个应用程序的崩溃。
   - 协程的异常处理通常由协程本身控制，可以实现局部异常处理，不会影响到其他协程的执行。

总的来说，线程和协程是两种不同的并发编程模型，各有各的优势和适用场景。在选择使用线程还是协程时，需要根据具体的需求和情况来进行权衡和选择。


### 二、大前端 （⭐⭐）

#### 1、Hybrid通信原理是什么，有做研究吗？

#### 2、JS的交互理解吗？平时工作用的多吗，项目中是怎么与Web交互的？

##### Android通过WebView调用JS代码：

1、通过WebView的loadUrl()：

- 设置与Js交互的权限：

  webSettings.setJavaScriptEnabled(true)
  
- 设置允许JS弹窗：

  webSettings.setJavaScriptCanOpenWindowsAutomatically(true)
  
- 载入JS代码：

  mWebView.loadUrl("file:///android_asset/javascript.html")
  
- webview只是载体，内容的渲染需要使用webviewChromClient类去实现，通过设置WebChromeClient对象处理JavaScript的对话框。

特别注意：

JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。

2、通过WebView的evaluateJavascript()：

- 该方法比第一种方法效率更高、使用更简洁，因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。
- Android 4.4 后才可使用。

只需要将第一种方法的loadUrl()换成evaluateJavascript()即可，通过onReceiveValue()回调接收返回值。

建议：两种方法混合使用，即Android 4.4以下使用方法1，Android 4.4以上方法2。

##### JS通过WebView调用 Android 代码：

1、通过 WebView的addJavascriptInterface（）进行对象映射：

-定义一个与JS对象映射关系的Android类：AndroidtoJs：
- 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解。
- 通过addJavascriptInterface()将Java对象映射到JS对象。

优点：使用简单，仅将Android对象和JS对象映射即可。

缺点：addJavascriptInterface 接口引起远程代码执行漏洞，漏洞产生原因是：

当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。

2、通过 WebViewClient 的方法shouldOverrideUrlLoading ()回调拦截 url：

- Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url。
- 解析该 url 的协议。
- 如果检测到是预先约定好的协议，就调用相应方法。

  根据协议的参数，判断是否是所需要的url。
  一般根据scheme（协议格式） & authority（协议名）判断（前两个参数）。
  
优点：不存在方式1的漏洞；

缺点：JS获取Android方法的返回值复杂,如果JS想要得到Android方法的返回值，只能通过 WebView 的 loadUrl （）去执行 JS 方法把返回值传递回去。

3、通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息：

原理：

Android通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调分别拦截JS对话框
（警告框、确认框、输入框），得到他们的消息内容，然后解析即可。

常用的拦截是：拦截 JS的输入框（即prompt（）方法），因为只有prompt（）可以返回任意类型的值，操作最全面方便、更加灵活；而alert（）对话框没有返回值；confirm（）对话框只能返回两种状态（确定 / 取消）两个值。

![image](https://upload-images.jianshu.io/upload_images/944365-613b57c93dff2eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[Android：你要的WebView与 JS 交互方式 都在这里了](https://blog.csdn.net/carson_ho/article/details/64904691)


#### 3、react native有多少了解？讲一下原理。

#### 4、weex了解吗？如何自己实现类似技术？

#### 5、flutter了解吗？内部是如何实现跨平台的？如何实现多Native页面接入？如何实现对现有工程的flutter迁移？

#### 6、Dart语言有研究过吗？

#### 7、快应用了解吗？跟其她方式相比有什么优缺点？

#### 8、说说你用过的混合开发技术有哪些？各有什么优缺点？


### 三、脚本语言 （⭐⭐）

#### 1、脚本语言会吗?

#### 2、Python会吗？

[Python基础](https://jsonchao.github.io/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/)

[人工智能了解](https://jsonchao.github.io/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/)


#### 3、Gradle了解多少？groovy语法会吗？





